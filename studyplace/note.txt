微服务模块

1.建module
2.改pom
  <!--springboot web组件-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <!--日常通用jar包配置-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

3.写yml
server:
 port:

spring:
  application:
    name: cloud-payment-service

4.主启动Main
com.study.springcloud.OrderMain80

com.study.springcloud.PaymentMain

@SpringBootApplication
@EnableDiscoveryClient

    public static void main(String[] args) {
        SpringApplication.run(,args);
    }

5.业务类 dao、service、controller
com.study.springcloud
controller.PaymentController



服务注册中心：Eureka(AP)、Zookeeper(CP)、Consul(CP)、Nacoss

CAP理论:关注粒度是数据，而不是整体系统设计的
一个分布式系统不可能同时很好的满足一致性、可用性和分区容错性这三个需求，最多只能同时较好的满足两个
Consistency(强一致性)
Availability（可用性）
Partition tolerance（分区容错性）
NoSQL数据库根据CAP理论分成三大类
CA - 单点集群，满足一致性，可用性的系统，通常性能不是特别高
CP - 满足一致性，分区容忍性的系统，通常性能不是特别高
AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些



eureka(已停更)
自我保护模式中，不会注销任何服务实例
底层还是使用httpClient

多个eureka地址，可在host文件弄域名，添加
127.0.0.1 eureka7001.com
127.0.0.1 eureka7002.com

zookeeper
yml
#8004表示注册到zookeeper服务器的支付服务提供者端口号
server:
  port: 8004
#服务别名----注册zookeeper到注册中心名称
spring:
  application:
    name: cloud-payment-service
  cloud:
    zookeeper:
      connect-string: 127.0.0.1:2181
#      connect-string: 192.168.111.144:2181

consul
下载：https://www.consul.io/downloads.html
添加环境变量：E:\consul
cmd 命令窗口执行：consul agent -dev
consul 自带 UI 界面，打开网址：http://localhost:8500 ，可以看到当前注册的服务界面
cmd 命令窗口执行:consul.exe agent -server ui -bootstrap -client 0.0.0.0 -data-dir="E:\consul" -bind X.X.X.X
其中X.X.X.X为服务器ip,即可使用http://X.X.X.X:8500 访问ui而不是只能使用localhost连接
注意：添加环境变量之后有可能无法启动，需要到consul.exe文件夹下面去执行consul agent -dev


服务调用（Ribbon、LoadBalancer）
ribbon-----负载均衡+RestTemplate调用
（spring-cloud-starter-netflix-eureka-client 已集成ribbon不需另加依赖）
RestTemplate----
getForObject:返回对象为响应体重数据转化成的对象，可以理解为json
getForEntity:返回对象为ResponseEntity对象，包含了响应中的一些重要信息，比如响应头、响应状态码、响应体等。



负载均衡算法
轮询算法（取余）：rest接口第几次请求数 % 服务器集群总数量 = 实际调用服务器位置下标， 每次服务重启动后rest接口计数从1开始。

IRule
自己的规则不能放在启动类(@ComponentScan)的包内

Spring Cloud Ribbon 是基于Netflix Ribbon实现的一套客户端 负载均衡工具
主要功能是提供客户端的软件负载均衡算法和服务条用。
Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。
就是在配置文件中列出Load Balance后面所有的机器，Ribbon会自动帮助你基于某种规则（如简单轮询、随机连接等），去连接这些机器。

LB负载均衡：将用户的请求平摊的分配到多个服务商，从而达到系统HA（高可用）。
常见的负载均衡软件：Nginx、LVS,硬件F5等
两种方式LB
集中式LB：在服务的消费方和提供方之间使用独立的LB设施（F5硬件、Nginx），负责把访问请求通过某种策略转发至服务的提供方。
进程内LB：把LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。
（Ribbon就属于进程内LB,它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。）

Ribbon本地负责均衡客户端 VS Nginx服务端负载均衡区别
Nginx是服务器负载均衡，客户端所有请求都会交给nginx，然后由nginx实现转发请求。即负载均衡是由服务端实现的。
Ribbon是本地负载均衡，在调用微服务接口时，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术。

Ribbon工作步骤
第一步寻找EurekaServer,它优先选择在同一个区域内负载较少的server。
第二步再根据用户指定的策略（轮询、随机、根据响应时间加权），在server去到的服务注册列表中选择一个地址。


服务调用2（Feign、OpenFeign）
Feign
是一个声明式WebService客户端。使用Feign能让编写Web Service客户端更加简单。
它的使用方法是定义一个服务接口然后在尚明添加注解。Feign也支持可插拔式的编码器和解码器。
Spring Cloud和Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。
Feign可以与Eureka和Ribbon组合使用以支持负载均衡

旨在使编写Java Http客户端变得更容易。
Ribbon+RestTemplate，利用RestTemplate对http请求的封装处理，形成一套模板化的调用方法。
但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会被针对每个微服务自行封装一些客户端来包装这些依赖服务的调用。
所以，Feign在此基础上做了进一步封装，由它来帮助我们定义和实现依赖服务接口的定义。
在Feign的实现下，我们只需创建一个接口并使用注解的方式来配置它（以前是Dao接口上面标注Mapper注解，，现在是一个微服务接口上面标注一个Feign注解即可）
即可完成对服务提供方的接口绑定，简化了使用Spring cloud Ribbon时。自动封装服务调用客户端的开发量。

Feign集成了Ribbon
利用Ribbon维护了Paymeng的服务列表信息，并且通过轮询实现了客户端的负载均衡。
与Ribbon不同的是，通过Feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用

OpenFeign
在Feign的基础上支持SpringMVC的注解，如RequesMapping等。
@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务

<dependency>
    <groupId>org.springframew ork.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>


服务降级（Hystrix、resilience4j、sentinel）
Hystrix(已停更)
是一个用于处理分布式系统的 延迟 和 容错 的开源库，在分布式系统里，许多依赖不可避免的会调用失败，如超时、异常等。
Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性
“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），
向调用方返回一个符合预期的、可处理的备选响应（FallBack）,而不是长时间的等待或者抛出调用方法无法处理的异常，
这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延、乃至雪崩。

主要功能
1.服务降级 fallback
服务器忙，请稍后再试，不让客户端等待并立刻返回一个友好提示
出现降级的情况：程序运行异常、超时、服务熔断触发服务降级、线程池/信号量打满也会导致服务降级

在service/controller方法（服务端/客服端都可以--一般在客服端controller）使用注解@HystrixCommand可以用fallbackMethod指定处理方法，也可通过@HystrixCommand指定超时（3秒）：
需在启动类添加新注解 @EnableCircuitBreaker
@HystrixCommand(fallbackMethod = "paymentInfo_TimeOutHandler",commandProperties = {
            @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds",value = "3000")
})
客服端启动类添加注解@EnableHystrix，yml添加 feign.hystrix.enabled : true
全局注解 @DefaultProperties(defaultFallback = "")，没配置的@HystrixCommand,也会调用这个跳转方法,可解决代码膨胀

Service接口可以使用这种方法实现降级且解耦，@FeignClient(value = "CLOUD-PROVIDER-HYSTRIX-PAYMENT（调用服务器）",fallback = PaymentFallbackService.class（需要继承该service接口，错误调用的方法）)
可以让客户端自己调用提示，不至于显示报错页面

2.服务熔断 break （注解也是@HystrixCommand）
保险丝，达到最大访问访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法返回友好提示
熔断机制：是应对雪崩效应的一种微服务链路保护机制，当链路的某个微服务出错、不可用、响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的信息
当检测到该节点微服务调用响应正常后，恢复调用链路。

熔断类型：
熔断打开：请求不再进行调用当前服务，内部设置时钟一般为MTTR(平均故障处理时间),当打开时长达到所设时钟则进入半熔断状态
熔断关闭：熔断关闭不会对服务进行熔断
熔断半开：部分请求根据规则调用当前服务，如果请求成功且符合规则则认为当前服务恢复正常，关闭熔断

涉及断路器的三个重要参数：快照时间，请求总数阈值，错误百分比阈值
1：快照时间：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。
2：请求总数阈值：在快照时间窗内，必须满足请求总数阈值才有资格熔断。默认为20，意味着在10秒内，如果该hystrix命令的调用次数不足20次，即使所有的请求都超时或其他原因失效，断路器都不会打开。
3：错误百分比阈值：当请求总数在快照时间窗内超过了阈值，比如发生了30次调用，如果在这30次调用中，有15次发生了超时异常，也就是超过了50%的错误百分比，在默认设定50%阈值情况下，这时候就会将断路器打开。

断路器打开后
1.断路器打开后，再有请求调用的时候，将不会用主逻辑，而是直接调用降级fallback,通过断路器，实现了主动地发现错误并降级逻辑切换为主逻辑，减少响应延迟的效果。
2.原来的主逻辑要如何恢复？
hystrix为我们实现了自动恢复功能。
当熔断器打开，对主逻辑进行熔断后，hystrix会启动一个休眠时间窗，在这个时间窗内，降级逻辑是临时的成为主逻辑，
当休眠时间窗到期，断路器将进入半开状态，释放一次请求到原来的主逻辑上，如果此次请求正常返回，那么断路器将继续闭合，
主逻辑回复，如果这次请求依然有问题，断路器继续进入打开状态，休眠时间窗重新计时。

3.服务限流
秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行

// 接近实时的监控 flowlimit



服务网关（Zuul、Zuul2、gateway）


服务配置（Config、Nacos）


服务总线（Bus、Nacos）
