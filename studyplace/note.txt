微服务模块

1.建module
2.改pom
  <!--springboot web组件-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <!--日常通用jar包配置-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

3.写yml
server:
 port:

spring:
  application:
    name: cloud-payment-service

4.主启动Main
com.study.springcloud.OrderMain80

com.study.springcloud.PaymentMain

@SpringBootApplication
@EnableDiscoveryClient

    public static void main(String[] args) {
        SpringApplication.run(,args);
    }

5.业务类 dao、service、controller
com.study.springcloud
controller.PaymentController



服务注册中心：Eureka(AP)、Zookeeper(CP)、Consul(CP)、Nacoss

CAP理论:关注粒度是数据，而不是整体系统设计的
一个分布式系统不可能同时很好的满足一致性、可用性和分区容错性这三个需求，最多只能同时较好的满足两个
Consistency(强一致性)
Availability（可用性）
Partition tolerance（分区容错性）
NoSQL数据库根据CAP理论分成三大类
CA - 单点集群，满足一致性，可用性的系统，通常性能不是特别高
CP - 满足一致性，分区容忍性的系统，通常性能不是特别高
AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些



eureka(已停更)
自我保护模式中，不会注销任何服务实例
底层还是使用httpClient

多个eureka地址，可在host文件弄域名，添加
127.0.0.1 eureka7001.com
127.0.0.1 eureka7002.com

zookeeper
yml
#8004表示注册到zookeeper服务器的支付服务提供者端口号
server:
  port: 8004
#服务别名----注册zookeeper到注册中心名称
spring:
  application:
    name: cloud-payment-service
  cloud:
    zookeeper:
      connect-string: 127.0.0.1:2181
#      connect-string: 192.168.111.144:2181

consul
下载：https://www.consul.io/downloads.html
添加环境变量：E:\consul
cmd 命令窗口执行：consul agent -dev
consul 自带 UI 界面，打开网址：http://localhost:8500 ，可以看到当前注册的服务界面
cmd 命令窗口执行:consul.exe agent -server ui -bootstrap -client 0.0.0.0 -data-dir="E:\consul" -bind X.X.X.X
其中X.X.X.X为服务器ip,即可使用http://X.X.X.X:8500 访问ui而不是只能使用localhost连接
注意：添加环境变量之后有可能无法启动，需要到consul.exe文件夹下面去执行consul agent -dev


服务调用（Ribbon、LoadBalancer）
ribbon-----负载均衡+RestTemplate调用
（spring-cloud-starter-netflix-eureka-client 已集成ribbon不需另加依赖）
RestTemplate----
getForObject:返回对象为响应体重数据转化成的对象，可以理解为json
getForEntity:返回对象为ResponseEntity对象，包含了响应中的一些重要信息，比如响应头、响应状态码、响应体等。



负载均衡算法
轮询算法（取余）：rest接口第几次请求数 % 服务器集群总数量 = 实际调用服务器位置下标， 每次服务重启动后rest接口计数从1开始。

IRule
自己的规则不能放在启动类(@ComponentScan)的包内

Spring Cloud Ribbon 是基于Netflix Ribbon实现的一套客户端 负载均衡工具
主要功能是提供客户端的软件负载均衡算法和服务条用。
Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。
就是在配置文件中列出Load Balance后面所有的机器，Ribbon会自动帮助你基于某种规则（如简单轮询、随机连接等），去连接这些机器。

LB负载均衡：将用户的请求平摊的分配到多个服务商，从而达到系统HA（高可用）。
常见的负载均衡软件：Nginx、LVS,硬件F5等
两种方式LB
集中式LB：在服务的消费方和提供方之间使用独立的LB设施（F5硬件、Nginx），负责把访问请求通过某种策略转发至服务的提供方。
进程内LB：把LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。
（Ribbon就属于进程内LB,它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。）

Ribbon本地负责均衡客户端 VS Nginx服务端负载均衡区别
Nginx是服务器负载均衡，客户端所有请求都会交给nginx，然后由nginx实现转发请求。即负载均衡是由服务端实现的。
Ribbon是本地负载均衡，在调用微服务接口时，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术。

Ribbon工作步骤
第一步寻找EurekaServer,它优先选择在同一个区域内负载较少的server。
第二步再根据用户指定的策略（轮询、随机、根据响应时间加权），在server去到的服务注册列表中选择一个地址。


服务调用2（Feign、OpenFeign）
Feign
是一个声明式WebService客户端。使用Feign能让编写Web Service客户端更加简单。
它的使用方法是定义一个服务接口然后在尚明添加注解。Feign也支持可插拔式的编码器和解码器。
Spring Cloud和Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。
Feign可以与Eureka和Ribbon组合使用以支持负载均衡

旨在使编写Java Http客户端变得更容易。
Ribbon+RestTemplate，利用RestTemplate对http请求的封装处理，形成一套模板化的调用方法。
但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会被针对每个微服务自行封装一些客户端来包装这些依赖服务的调用。
所以，Feign在此基础上做了进一步封装，由它来帮助我们定义和实现依赖服务接口的定义。
在Feign的实现下，我们只需创建一个接口并使用注解的方式来配置它（以前是Dao接口上面标注Mapper注解，，现在是一个微服务接口上面标注一个Feign注解即可）
即可完成对服务提供方的接口绑定，简化了使用Spring cloud Ribbon时。自动封装服务调用客户端的开发量。

Feign集成了Ribbon
利用Ribbon维护了Paymeng的服务列表信息，并且通过轮询实现了客户端的负载均衡。
与Ribbon不同的是，通过Feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用

OpenFeign
在Feign的基础上支持SpringMVC的注解，如RequesMapping等。
@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务

<dependency>
    <groupId>org.springframew ork.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>


服务降级（Hystrix、resilience4j、sentinel）
Hystrix(已停更)
是一个用于处理分布式系统的 延迟 和 容错 的开源库，在分布式系统里，许多依赖不可避免的会调用失败，如超时、异常等。
Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性
“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），
向调用方返回一个符合预期的、可处理的备选响应（FallBack）,而不是长时间的等待或者抛出调用方法无法处理的异常，
这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延、乃至雪崩。

主要功能
1.服务降级 fallback
服务器忙，请稍后再试，不让客户端等待并立刻返回一个友好提示
出现降级的情况：程序运行异常、超时、服务熔断触发服务降级、线程池/信号量打满也会导致服务降级

在service/controller方法（服务端/客服端都可以--一般在客服端controller）使用注解@HystrixCommand可以用fallbackMethod指定处理方法，也可通过@HystrixCommand指定超时（3秒）：
需在启动类添加新注解 @EnableCircuitBreaker
@HystrixCommand(fallbackMethod = "paymentInfo_TimeOutHandler",commandProperties = {
            @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds",value = "3000")
})
客服端启动类添加注解@EnableHystrix，yml添加 feign.hystrix.enabled : true
全局注解 @DefaultProperties(defaultFallback = "")，没配置的@HystrixCommand,也会调用这个跳转方法,可解决代码膨胀

Service接口可以使用这种方法实现降级且解耦，@FeignClient(value = "CLOUD-PROVIDER-HYSTRIX-PAYMENT（调用服务器）",fallback = PaymentFallbackService.class（需要继承该service接口，错误调用的方法）)
可以让客户端自己调用提示，不至于显示报错页面

2.服务熔断 break （注解也是@HystrixCommand）
保险丝，达到最大访问访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法返回友好提示
熔断机制：是应对雪崩效应的一种微服务链路保护机制，当链路的某个微服务出错、不可用、响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的信息
当检测到该节点微服务调用响应正常后，恢复调用链路。

熔断类型：
熔断打开：请求不再进行调用当前服务，内部设置时钟一般为MTTR(平均故障处理时间),当打开时长达到所设时钟则进入半熔断状态
熔断关闭：熔断关闭不会对服务进行熔断
熔断半开：部分请求根据规则调用当前服务，如果请求成功且符合规则则认为当前服务恢复正常，关闭熔断

涉及断路器的三个重要参数：快照时间，请求总数阈值，错误百分比阈值
1：快照时间：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。
2：请求总数阈值：在快照时间窗内，必须满足请求总数阈值才有资格熔断。默认为20，意味着在10秒内，如果该hystrix命令的调用次数不足20次，即使所有的请求都超时或其他原因失效，断路器都不会打开。
3：错误百分比阈值：当请求总数在快照时间窗内超过了阈值，比如发生了30次调用，如果在这30次调用中，有15次发生了超时异常，也就是超过了50%的错误百分比，在默认设定50%阈值情况下，这时候就会将断路器打开。

断路器打开后
1.断路器打开后，再有请求调用的时候，将不会用主逻辑，而是直接调用降级fallback,通过断路器，实现了主动地发现错误并降级逻辑切换为主逻辑，减少响应延迟的效果。
2.原来的主逻辑要如何恢复？
hystrix为我们实现了自动恢复功能。
当熔断器打开，对主逻辑进行熔断后，hystrix会启动一个休眠时间窗，在这个时间窗内，降级逻辑是临时的成为主逻辑，
当休眠时间窗到期，断路器将进入半开状态，释放一次请求到原来的主逻辑上，如果此次请求正常返回，那么断路器将继续闭合，
主逻辑回复，如果这次请求依然有问题，断路器继续进入打开状态，休眠时间窗重新计时。

3.服务限流
秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行

接近实时的监控 flowlimit
除了隔离依赖服务外，Hystrix还提供了准实时的调用监控（Hystrix DashBoard）,Hystrix会持续地记录所有通过Hystrix发起的请求的执行信息，
并以统计报表和图形的形式展示给用户，包括每秒执行多少，请求多少成功，多少失败等。
Netfilx通过Hystrix-metrics-event-stream项目实现了对以上指标的监控。
Spring Cloud也提供了Hystrix DashBoard的整合，对监控内容转化成可视化界面。
pom引用，启动服务后可在http://localhost:xxx/hystrix看到相关信息
  <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-hystrix-dashboard</artifactId>
        </dependency>
监控时pom要有web组件依赖（web、actuator）

服务网关（Zuul、Zuul2、gateway）

Zuul（路由网关）
netflix,zuul维护,zuul2跳票出不来成品，逐渐废弃
官网：https://github.com/Netflix/zuul/wiki
使用传统的Servlet IO处理模型。
缺点
servlet是一个简单的网络IO模型，在并发不高的情景下这种模型是使用的。
但是高并发，线程数量机会上涨，而线程资源代价是昂贵的（上下文切换，内存消耗大）严重影响请求的处理时间。
在一些简单业务场景下，不希望为每个request分配一个线程，只需要1个或几个线程就能应对极大并发的请求，这种业务场景下servlet模型没有优势。
因此Zuul 1.x是基于servlet之上的一个阻塞式处理模型，即spring实行了处理所有request请求的一个servlet（DispatcherServlet）并有该servlet阻塞式处理
所以Spring cloud Zuul无法摆脱servlet模型的弊端

Zuul和gateway的区别
Spring cloud Finchley正式版之前，推荐网关是Netflix提供的Zuul;
1、Zuul 1.x 是一个基于阻塞I/O的API Gateway
2、Zuul 1.x基于Servlet 2.5使用阻塞框架，它不支持任何长连接（如WebSocket）Zuul的设计模式和Nginx交像，
每次I/O操作都是从工作线程中选择一个执行，请求线程被阻塞到工程线程完成，
但是差别是Nginx用C++实现，Zuul用java实现，而JVM本身会有第一次加载较慢的情况，使得Zuul的性能相对较差。
3、Zuul 2.x理念更先进，想基于Netty非阻塞和支持长连接，但SpringCloud目前还没有整合。Zuul 2.x的性能较Zuul 1.x有较大提升，
在性能方面，官方提供的基准测试，Spring Cloud Gateway的RPS(每秒请求数) 是Zuul的1.6倍。
4、Spring Cloud Gateway 建立在Spring framework 5,Spring boot2.x、Spring WebFlux 、Project Reactor之上，使用非阻塞API.
5、Spring Cloud Gateway 还支持WebSocket，并且与Spring紧密集成拥有更好地开发体验。

WebFlux
传统的web框架，如struts2，springmvc等都是基于servlet API与Servlet容器基础上运行的。
但Servlet3.1之后有了异步非阻塞的支持。
而WebFlux是一个典型非阻塞异步的框架，它的核心是基于Reactor的相关API实现的。
相对于传统web框架来说，它可以运行在诸如Netty，Undertow及支持Servlet3.1的容器上。
非阻塞式+函数式编程(Spring5必须让你使用java8)
SpringWebFlux 是Spring 5.0 引入的新的响应式框架，区别于Spring MVC，它不需要依赖Servlet API，它是完全异步非阻塞的，并且基于Reactor来实现响应式流规范。


gateway（新一代网关、spring自己出，整合了环境Spring framework 5,Spring boot2.x、Spring WebFlux 、Project Reactor）
gateway是zuul 1.x的替代版，基于WebFlux框架实现，WebFlux框架底层则是使用了高性能的Reactor模式通信框架Netty(建议看韩顺平讲解netty)
Spring cloud gateway的目标提供统一的路由方式且基于Filter链的方式提供网关的基本功能，如：安全，监控/指标，限流。
动态路由：能够匹配任何请求属性
可以对指定Predicate(通信)和Filter(过滤器);
集成Hystrix的断路器功能；
集成Spring Cloud服务发现功能；
易于编写的Predicate(通信)和Filter(过滤器);
请求限流功能；
支持路径重写。

gateway三大核心概念
Route(路由)
构建网关的基本模块，它由ID,目标URI,一系列的断言和过滤器组成，如果断言为true则匹配该路由

Predicate(断言-----九种方式，参考9527项目的yml)
参考的是Java8的java.util.function.Predicate
开发人员可以匹配HTTP请求中的所有内容（例如请求头或请求参数），如果请求与断言相匹配则进行路由

Gateway包括许多内置的Route Predicate工厂。所有这些predicate都与Http请求的不同属性匹配。多个Route Predicate工厂可以进行组合
Gateway创建Route 对象时，使用RoutePredicateFactory创建Predicate对象,Predicate对象可以赋值给Route。

可在cmd里用curl测试接口（可带cookie  url --cookie "xxxx=xxx"、Header  url -H "xxxx"）

Filter(过滤)
指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。

生命周期
pre

post

种类
GatewayFilter(局部--31种，可在官网看)
GlobalFilter（全局--10+种）
配置yml filter  或自定义过滤器

GateWay总体
web请求，通过一些匹配条件，定位到真正的服务节点，并在这个转发过程的前后，进行一些精细化控制。
predicate就是我们的匹配条件；而filter，可理解为一个无所不能的拦截器。
有了这两个元素，再加上目标uri，就可以实现一个具体的路由了。

客户端向Gateway发出请求，然后在Gateway Handler Mapping 中找到与请求相匹配的路由，将其发到Gateway web Handler.
Handler再通过指定的过滤器链来讲请求发送到我们实际的服务执行业务逻辑，然后返回。
过滤器可能会在发送代理请求之前（"pre"）或之后("post")执行业务逻辑。
Filter在"pre"类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等，
在"post"类型的过滤器中可以做响应内容、响应头的修改，日志的输出、就来监控等。

gateway----pom.xml
<dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-gateway</artifactId>
        </dependency>
带eureka.
不能带starter-web，不然启动会报错

gateway配置网关路由的两种方法
在配置文件yml中配置
代码中注入RouteLocator的Bean

动态路由
默认情况下Gateway会根据注册中心注册的服务列表，以注册中心上微服务名为路径创建动态路由进行转发，从而实现动态路由的功能



服务配置（Config、Nacos）


服务总线（Bus、Nacos）
